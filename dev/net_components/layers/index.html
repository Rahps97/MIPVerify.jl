<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Layers · MIPVerify</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIPVerify</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Finding Adversarial Examples</span><ul><li><a class="toctext" href="../../finding_adversarial_examples/single_image/">Single Image</a></li><li><a class="toctext" href="../../finding_adversarial_examples/batch_processing/">Batch Processing</a></li></ul></li><li><span class="toctext">Importing</span><ul><li><a class="toctext" href="../../utils/import_example_nets/">Example Neural Networks</a></li><li><a class="toctext" href="../../utils/import_weights/">Helpers for importing individual layers</a></li><li><a class="toctext" href="../../utils/import_datasets/">Datasets</a></li></ul></li><li><span class="toctext">Working with Neural Net Parameters</span><ul><li><a class="toctext" href="../overview/">Overview</a></li><li class="current"><a class="toctext" href>Layers</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Public-Interface-1">Public Interface</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li><li><a class="toctext" href="../nets/">Networks</a></li><li><a class="toctext" href="../core_ops/">Core Operations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Working with Neural Net Parameters</li><li><a href>Layers</a></li></ul><a class="edit-page" href="https://github.com/vtjeng/MIPVerify.jl/blob/master/docs/src/net_components/layers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Layers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Layers-1" href="#Layers-1">Layers</a></h1><p>Each layer in the neural net corresponds to a <code>struct</code> that simultaneously specifies: 1) the operation being carried out in the layer (recorded in the type of the <code>struct</code>) and 2) the parameters for the operation (recorded in the values of the fields of the <code>struct</code>).</p><p>When we pass an input array of real numbers to a layer <code>struct</code>, we get an output array of real numbers that is the result of the layer operating on the input.</p><p>Conversely, when we pass an input array of <code>JuMP</code> variables, we get an output array of <code>JuMP</code> variables, with the appropriate mixed-integer constraints (as determined by the layer) imposed between the input and output.</p><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#MIPVerify.MaxPool-Union{Tuple{Tuple{Vararg{Int64,N}}}, Tuple{N}} where N"><code>MIPVerify.MaxPool</code></a></li><li><a href="#MIPVerify.conv2d-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Array{T,4},Conv2d{U,V,V1} where V1&lt;:Int64}} where V&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where U&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.conv2d</code></a></li><li><a href="#MIPVerify.getoutputsize-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}}}} where N where T"><code>MIPVerify.getoutputsize</code></a></li><li><a href="#MIPVerify.getpoolview-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}} where N where T"><code>MIPVerify.getpoolview</code></a></li><li><a href="#MIPVerify.getsliceindex-Tuple{Integer,Integer,Integer}"><code>MIPVerify.getsliceindex</code></a></li><li><a href="#MIPVerify.matmul-Tuple{Array{#s248,1} where #s248&lt;:Real,Linear}"><code>MIPVerify.matmul</code></a></li><li><a href="#MIPVerify.matmul-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Array{T,1},Linear{U,V}}} where V&lt;:Real where U&lt;:Real where T&lt;:Union{GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.matmul</code></a></li><li><a href="#MIPVerify.permute_and_flatten-Union{Tuple{U}, Tuple{N}, Tuple{T}, Tuple{Array{T,N},AbstractArray{U,N} where N}} where U&lt;:Integer where N where T"><code>MIPVerify.permute_and_flatten</code></a></li><li><a href="#MIPVerify.pool-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Pool{N}}} where N where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.pool</code></a></li><li><a href="#MIPVerify.poolmap-Union{Tuple{N}, Tuple{T}, Tuple{Function,AbstractArray{T,N},Tuple{Vararg{Int64,N}}}} where N where T"><code>MIPVerify.poolmap</code></a></li><li><a href="#MIPVerify.Conv2d"><code>MIPVerify.Conv2d</code></a></li><li><a href="#MIPVerify.Conv2d-Union{Tuple{Array{T,4}}, Tuple{T}} where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.Conv2d</code></a></li><li><a href="#MIPVerify.Flatten"><code>MIPVerify.Flatten</code></a></li><li><a href="#MIPVerify.Linear"><code>MIPVerify.Linear</code></a></li><li><a href="#MIPVerify.MaskedReLU"><code>MIPVerify.MaskedReLU</code></a></li><li><a href="#MIPVerify.Pool"><code>MIPVerify.Pool</code></a></li><li><a href="#MIPVerify.ReLU"><code>MIPVerify.ReLU</code></a></li></ul><h2><a class="nav-anchor" id="Public-Interface-1" href="#Public-Interface-1">Public Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Conv2d" href="#MIPVerify.Conv2d"><code>MIPVerify.Conv2d</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Conv2d{T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}, U&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}, V&lt;:Int64} &lt;: Layer</code></pre><p>Represents 2-D convolution operation.</p><p><code>p(x)</code> is shorthand for <a href="#MIPVerify.conv2d-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Array{T,4},Conv2d{U,V,V1} where V1&lt;:Int64}} where V&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where U&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>conv2d(x, p)</code></a> when <code>p</code> is an instance of <code>Conv2d</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>filter</code></p></li><li><p><code>bias</code></p></li><li><p><code>stride</code></p></li><li><p><code>padding</code></p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Conv2d-Union{Tuple{Array{T,4}}, Tuple{T}} where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}" href="#MIPVerify.Conv2d-Union{Tuple{Array{T,4}}, Tuple{T}} where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.Conv2d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Conv2d(filter)
</code></pre><p>Convenience function to create a <a href="#MIPVerify.Conv2d"><code>Conv2d</code></a> struct with the specified filter and zero bias.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Flatten" href="#MIPVerify.Flatten"><code>MIPVerify.Flatten</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Flatten{T&lt;:Integer} &lt;: Layer</code></pre><p>Represents a flattening operation.</p><p><code>p(x)</code> is shorthand for <a href="#MIPVerify.permute_and_flatten-Union{Tuple{U}, Tuple{N}, Tuple{T}, Tuple{Array{T,N},AbstractArray{U,N} where N}} where U&lt;:Integer where N where T"><code>permute_and_flatten(x, p.perm)</code></a> when <code>p</code> is an instance of <code>Flatten</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>n_dim</code></p></li><li><p><code>perm</code></p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Linear" href="#MIPVerify.Linear"><code>MIPVerify.Linear</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Linear{T&lt;:Real, U&lt;:Real} &lt;: Layer</code></pre><p>Represents matrix multiplication.</p><p><code>p(x)</code> is shorthand for <a href="#MIPVerify.matmul-Tuple{Array{#s248,1} where #s248&lt;:Real,Linear}"><code>matmul(x, p)</code></a> when <code>p</code> is an instance of <code>Linear</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>matrix</code></p></li><li><p><code>bias</code></p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.MaskedReLU" href="#MIPVerify.MaskedReLU"><code>MIPVerify.MaskedReLU</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct MaskedReLU{T&lt;:Real} &lt;: Layer</code></pre><p>Represents a masked ReLU activation, with <code>mask</code> controlling how the ReLU is applied to each output.</p><p><code>p(x)</code> is shorthand for <a href="../core_ops/#MIPVerify.masked_relu-Tuple{AbstractArray{#s167,N} where N where #s167&lt;:Union{GenericAffExpr{Float64,VariableRef}, VariableRef},AbstractArray{#s168,N} where N where #s168&lt;:Real}"><code>masked_relu(x, p.mask)</code></a> when <code>p</code> is an instance of <code>MaskedReLU</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>mask</code></p></li><li><p><code>tightening_algorithm</code></p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.MaxPool-Union{Tuple{Tuple{Vararg{Int64,N}}}, Tuple{N}} where N" href="#MIPVerify.MaxPool-Union{Tuple{Tuple{Vararg{Int64,N}}}, Tuple{N}} where N"><code>MIPVerify.MaxPool</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convenience function to create a <a href="#MIPVerify.Pool"><code>Pool</code></a> struct for max-pooling.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Pool" href="#MIPVerify.Pool"><code>MIPVerify.Pool</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Pool{N} &lt;: Layer</code></pre><p>Represents a pooling operation.</p><p><code>p(x)</code> is shorthand for <a href="#MIPVerify.pool-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Pool{N}}} where N where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>pool(x, p)</code></a> when <code>p</code> is an instance of <code>Pool</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>strides</code></p></li><li><p><code>pooling_function</code></p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.ReLU" href="#MIPVerify.ReLU"><code>MIPVerify.ReLU</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ReLU &lt;: Layer</code></pre><p>Represents a ReLU operation.</p><p><code>p(x)</code> is shorthand for <a href="../core_ops/#MIPVerify.relu-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T&lt;:Union{GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>relu(x)</code></a> when <code>p</code> is an instance of <code>ReLU</code>.</p></div></div></section><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.conv2d-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Array{T,4},Conv2d{U,V,V1} where V1&lt;:Int64}} where V&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where U&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}" href="#MIPVerify.conv2d-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Array{T,4},Conv2d{U,V,V1} where V1&lt;:Int64}} where V&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where U&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef} where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.conv2d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">conv2d(input, params)
</code></pre><p>Computes the result of convolving <code>input</code> with the <code>filter</code> and <code>bias</code> stored in <code>params</code>.</p><p>Mirrors <code>tf.nn.conv2d</code> from the <code>tensorflow</code> package, with <code>strides = [1, params.stride, params.stride, 1]</code>.</p><p>Supports three types of padding:</p><ul><li>&#39;same&#39;:  Specify via <code>SamePadding()</code>. Padding is added so that the output has the same size as the input.</li><li>&#39;valid&#39;: Specify via <code>FixedPadding()</code>. No padding is added.</li><li>&#39;fixed&#39;: Specify via:<ul><li>A single integer, interpreted as padding for both axes</li><li>A tuple of two integers, interpreted as (y<em>padding, x</em>padding)</li><li>A tuple of four integers, interpreted as (top, bottom, left, right)</li></ul></li></ul><p><strong>Throws</strong></p><ul><li>AssertionError if <code>input</code> and <code>filter</code> are not compatible.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.permute_and_flatten-Union{Tuple{U}, Tuple{N}, Tuple{T}, Tuple{Array{T,N},AbstractArray{U,N} where N}} where U&lt;:Integer where N where T" href="#MIPVerify.permute_and_flatten-Union{Tuple{U}, Tuple{N}, Tuple{T}, Tuple{Array{T,N},AbstractArray{U,N} where N}} where U&lt;:Integer where N where T"><code>MIPVerify.permute_and_flatten</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Permute dimensions of array in specified order, then flattens the array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.matmul-Tuple{Array{#s248,1} where #s248&lt;:Real,Linear}" href="#MIPVerify.matmul-Tuple{Array{#s248,1} where #s248&lt;:Real,Linear}"><code>MIPVerify.matmul</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">matmul(x, params)
</code></pre><p>Computes the result of pre-multiplying <code>x</code> by the transpose of <code>params.matrix</code> and adding <code>params.bias</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.matmul-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Array{T,1},Linear{U,V}}} where V&lt;:Real where U&lt;:Real where T&lt;:Union{GenericAffExpr{Float64,VariableRef}, VariableRef}" href="#MIPVerify.matmul-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Array{T,1},Linear{U,V}}} where V&lt;:Real where U&lt;:Real where T&lt;:Union{GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.matmul</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">matmul(x, params)
</code></pre><p>Computes the result of pre-multiplying <code>x</code> by the transpose of <code>params.matrix</code> and adding <code>params.bias</code>. We write the computation out by hand when working with <code>JuMPLinearType</code> so that we are able to simplify the output as the computation is carried out.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.getoutputsize-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}}}} where N where T" href="#MIPVerify.getoutputsize-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}}}} where N where T"><code>MIPVerify.getoutputsize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getoutputsize(input_array, strides)
</code></pre><p>For pooling operations on an array, returns the expected size of the output array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.getpoolview-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}} where N where T" href="#MIPVerify.getpoolview-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}} where N where T"><code>MIPVerify.getpoolview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getpoolview(input_array, strides, output_index)
</code></pre><p>For pooling operations on an array, returns a view of the parent array corresponding to the <code>output_index</code> in the output array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.getsliceindex-Tuple{Integer,Integer,Integer}" href="#MIPVerify.getsliceindex-Tuple{Integer,Integer,Integer}"><code>MIPVerify.getsliceindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getsliceindex(input_array_size, stride, output_index)
</code></pre><p>For pooling operations on an array where a given element in the output array corresponds to equal-sized blocks in the input array, returns (for a given dimension) the index range in the input array corresponding to a particular index <code>output_index</code> in the output array.</p><p>Returns an empty array if the <code>output_index</code> does not correspond to any input indices.</p><p><strong>Arguments</strong></p><ul><li><code>stride::Integer</code>: the size of the operating blocks along the active    dimension.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.pool-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Pool{N}}} where N where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}" href="#MIPVerify.pool-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Pool{N}}} where N where T&lt;:Union{Real, GenericAffExpr{Float64,VariableRef}, VariableRef}"><code>MIPVerify.pool</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pool(input, params)
</code></pre><p>Computes the result of applying the pooling function <code>params.pooling_function</code> to non-overlapping cells of <code>input</code> with sizes specified in <code>params.strides</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.poolmap-Union{Tuple{N}, Tuple{T}, Tuple{Function,AbstractArray{T,N},Tuple{Vararg{Int64,N}}}} where N where T" href="#MIPVerify.poolmap-Union{Tuple{N}, Tuple{T}, Tuple{Function,AbstractArray{T,N},Tuple{Vararg{Int64,N}}}} where N where T"><code>MIPVerify.poolmap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">poolmap(f, input_array, strides)
</code></pre><p>Returns output from applying <code>f</code> to subarrays of <code>input_array</code>, with the windows determined by the <code>strides</code>.</p></div></div></section><footer><hr/><a class="previous" href="../overview/"><span class="direction">Previous</span><span class="title">Overview</span></a><a class="next" href="../nets/"><span class="direction">Next</span><span class="title">Networks</span></a></footer></article></body></html>
